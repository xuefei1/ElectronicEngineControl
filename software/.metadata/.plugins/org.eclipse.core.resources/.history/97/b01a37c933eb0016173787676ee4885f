/*
 * apps_motor_proc.c
 *
 * Status: C
 *
 *  Created on: Feb 2, 2017
 *      Author: Fred
 *
 *      Process handling accelerator pedal position input
 *      and digital servo motor driving
 *
 *		*See proj_config.h for acronym translations
 */
#include "apps_motor_proc.h"

/* Used to store new expected throttle position */
OS_EVENT *expected_motor_pos_q;

/* Used to signal TPS a new reading should be available */
OS_EVENT *new_tps_reading;

/* Used to accept possible commands from other modules */
OS_EVENT *motor_cmd_q;

char motor_pos_q_buf[EXPECTED_MOTOR_POS_Q_SIZE_BYTE];

char motor_cmd_q_buf[MOTOR_CMD_Q_SIZE_BYTE];

/*  Task routine for pedal position sensor and motor */
void apps_motor_task(void* pdata) {

	alt_up_de0_nano_adc_dev* adc = get_adc();

	static INT16U last_apps_1_reading = 0;
	static INT16U last_apps_2_reading = 0;

	expected_motor_pos_q = OSQCreate((void*) motor_pos_q_buf,
			EXPECTED_MOTOR_POS_Q_SIZE_BYTE / sizeof(INT16U));
	if (expected_motor_pos_q == NULL) {
		printf("failed to init q\n");
		return;
	}

	motor_cmd_q = OSQCreate((void*) motor_cmd_q_buf,
			MOTOR_CMD_Q_SIZE_BYTE / sizeof(INT16U));
	if (motor_cmd_q == NULL) {
		printf("failed to init q\n");
		return;
	}

	new_tps_reading = OSSemCreate(NEW_TPS_READING_SEM_COUNT);

	while (1) {
		alt_up_de0_nano_adc_update(adc);

		INT16U apps_1_reading = alt_up_de0_nano_adc_read(adc,
				APPS_1_ADC_CHANNEL);
		INT16U apps_2_reading = alt_up_de0_nano_adc_read(adc,
				APPS_2_ADC_CHANNEL);

		if (APPS_VALUE_CHANGED(apps_1_reading,
				last_apps_1_reading)
				|| APPS_VALUE_CHANGED(apps_2_reading, last_apps_2_reading)) {
			if (APPS_VALUE_MISMATCH(apps_1_reading, apps_2_reading)) {
				//we have a failure, turn off motor, indicate failure and block

			} else {
				//determine new motor position

			}
		}
		OSTimeDlyHMSM(APPS_MOTOR_TASK_DELAY_HOURS,
				APPS_MOTOR_TASK_DELAY_MINUTES, APPS_MOTOR_TASK_DELAY_SECONDS,
				APPS_MOTOR_TASK_DELAY_MILLISEC);
	}
}

/* Getter for expected motor position Q for TPS process to use */
OS_EVENT* get_expected_motor_pos_q() {
	return expected_motor_pos_q;
}

/* Getter for new TPS reading semaphore for TPS process to pend on */
OS_EVENT* get_new_tps_reading_sem(){
	return new_tps_reading;
}
