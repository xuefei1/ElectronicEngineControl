/*
 * tps_proc.c
 *
 * Status: C
 *
 *  Created on: Feb 4, 2017
 *      Author: xuefei1
 *
 *      Throttle Position Sensor process
 *
 *      *See proj_config.h for acronym translations
 */

#include "tps_proc.h"
#include "apps_motor_proc.h"

/* Flag indicating possible APPS failure */
OS_EVENT *tps_failure_flag;

/* Flag indicating failures detected in other tasks */
OS_EVENT *external_failure_flag;

/* Flag indicating failure resolved */
OS_EVENT *failure_resolved_flag;

OS_EVENT* failure_msg_q;

/*  Task routine for interfacing with throttle position sensors */
void tps_task(void* pdata) {

	INT8U err;

	alt_up_de0_nano_adc_dev* adc = get_adc();

	OS_EVENT *expected_tps_reading_q = get_expected_motor_pos_q();

	failure_msg_q = get_failure_msg_q();

	apps_failure_flag = OSSemCreate(SEM_FLAG_NO_ERROR);

	external_failure_flag = OSSemCreate(SEM_FLAG_NO_ERROR);

	failure_resolved_flag = OSSemCreate(SEM_FLAG_ERROR_UNRESOLVED);

	alt_alarm* expected_pos_alarm;

	BOOL expected_pos_check_timer_activated = FALSE;

	alt_alarm* tps_cehck_alarm;

	BOOL tps_check_timer_activated = FALSE;

	while (1) {

		INT16U expected_pos = *(INT16U*) OSQPend(expected_tps_reading_q,
				Q_TIMEOUT_WAIT_FOREVER, &err);

		if (err)
			disp_err(err, "Error pending on expected value q");

		alt_up_de0_nano_adc_update(adc);

		//activate expected position checker
		if(expected_pos_check_timer_activated == TRUE){
			alt_alarm_stop (expected_pos_alarm);
			free(expected_pos_alarm);
		}

		expected_pos_alarm = (alt_alarm*)malloc(sizeof(alt_alarm));
		alt_alarm_start(expected_pos_alarm, MOTOR_DRIVE_DELAY_TICKS, &apps_value_comp_callback, NULL);

		INT16U tps_1_reading = alt_up_de0_nano_adc_read(adc, TPS_1_ADC_CHANNEL);
		INT16U tps_2_reading = alt_up_de0_nano_adc_read(adc, TPS_2_ADC_CHANNEL);

		if (TPS_VALUE_MISMATCH(tps_1_reading, tps_2_reading)) {
			//we have a failure, signal failure handler

		} else {
			//determine if throttle reached expected position
			if (TPS_VALUE_DIFFER_FROM_EXPECTED(tps_2_reading, expected_pos)
					|| TPS_VALUE_DIFFER_FROM_EXPECTED(tps_1_reading, expected_pos)) {
				//possible motor failure, signal failure handler

			}
		}
		OSTimeDlyHMSM(TPS_TASK_DELAY_HOURS, TPS_TASK_DELAY_MINUTES,
				TPS_TASK_DELAY_SECONDS, TPS_TASK_DELAY_MILLISEC);
	}
}

/* Callback function to check motor position */
alt_u32 apps_value_comp_callback(void* context){
	alt_up_de0_nano_adc_update(adc);
	INT16U tps_1_reading = alt_up_de0_nano_adc_read(adc, TPS_1_ADC_CHANNEL);
	INT16U tps_2_reading = alt_up_de0_nano_adc_read(adc, TPS_2_ADC_CHANNEL);
	if (TPS_VALUE_MISMATCH(tps_1_reading, tps_2_reading)) {

		OSQPost(failure_msg_q, (void*) ERR_EXPECTED_THROTTLE_POS_MISMATCH);

	}
	return 0;
}
